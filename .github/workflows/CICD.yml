name: CI/CD Pipeline

on:
  push:
    branches:
      - main

env:
  AWS_REGION: eu-central-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.eu-central-1.amazonaws.com
  ECS_CLUSTER: praychain-cluster
  ECS_SERVICE: praychain-service
  DOMAIN: praychain.pl

jobs:
  # ==================== CI - Build ====================
  ci:
    name: CI - Build Docker Images
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create .htpasswd file
        run: |
          echo "${{ secrets.HTPASSWD_CONTENT }}" > nginx/.htpasswd

      - name: Build Docker images
        run: |
          echo "üî® Building Docker images..."
          docker build -t praychain-nginx:latest -f nginx/Dockerfile nginx/
          echo "‚úÖ nginx built"
          docker build -t praychain-backend:latest -f backend/Dockerfile backend/
          echo "‚úÖ backend built"
          docker build -t praychain-voice:latest -f voice-service/Dockerfile voice-service/
          echo "‚úÖ voice-service built"

      - name: Build Summary
        run: |
          echo "‚úÖ All Docker images built successfully!"
          docker images | grep praychain

  # ==================== CD - Deploy ====================
  cd:
    name: CD - Deploy to AWS ECS
    needs: ci
    if: vars.DEPLOY_ON_PR == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create .htpasswd file
        run: |
          echo "${{ secrets.HTPASSWD_CONTENT }}" > nginx/.htpasswd

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repositories if not exist
        run: |
          for repo in praychain-nginx praychain-backend praychain-voice; do
            if ! aws ecr describe-repositories --repository-names $repo --region ${{ env.AWS_REGION }} 2>/dev/null; then
              echo "Creating repository: $repo"
              aws ecr create-repository --repository-name $repo --region ${{ env.AWS_REGION }}
            fi
          done

      - name: Build, Tag and Push images to ECR
        run: |
          # Build
          docker build -t praychain-nginx:latest -f nginx/Dockerfile nginx/
          docker build -t praychain-backend:latest -f backend/Dockerfile backend/
          docker build -t praychain-voice:latest -f voice-service/Dockerfile voice-service/
          
          # Tag
          docker tag praychain-nginx:latest ${{ env.ECR_REGISTRY }}/praychain-nginx:latest
          docker tag praychain-backend:latest ${{ env.ECR_REGISTRY }}/praychain-backend:latest
          docker tag praychain-voice:latest ${{ env.ECR_REGISTRY }}/praychain-voice:latest
          
          # Push
          docker push ${{ env.ECR_REGISTRY }}/praychain-nginx:latest
          docker push ${{ env.ECR_REGISTRY }}/praychain-backend:latest
          docker push ${{ env.ECR_REGISTRY }}/praychain-voice:latest

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Init & Apply
        working-directory: terraform
        run: |
          # Inicjalizacja Terraform
          terraform init
          
          # Sprawd≈∫ czy infrastruktura istnieje, je≈õli nie - utw√≥rz
          terraform apply -auto-approve

      - name: Deploy to ECS
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Wait for ECS service to stabilize
        run: |
          echo "‚è≥ Waiting for ECS service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }}

      - name: Get ECS Task Public IP
        id: get-ip
        run: |
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'taskArns[0]' \
            --output text)

          ENI_ID=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --tasks $TASK_ARN \
            --region ${{ env.AWS_REGION }} \
            --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
            --output text)

          PUBLIC_IP=$(aws ec2 describe-network-interfaces \
            --network-interface-ids $ENI_ID \
            --region ${{ env.AWS_REGION }} \
            --query 'NetworkInterfaces[0].Association.PublicIp' \
            --output text)

          echo "Public IP: $PUBLIC_IP"
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT

      - name: Update Cloudflare DNS Records
        run: |
          PUBLIC_IP="${{ steps.get-ip.outputs.public_ip }}"
          echo "üåê Updating DNS records to: $PUBLIC_IP"

          # Get record IDs
          ROOT_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/dns_records?type=A&name=${{ env.DOMAIN }}" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" | jq -r '.result[0].id')

          WWW_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/dns_records?type=A&name=www.${{ env.DOMAIN }}" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" | jq -r '.result[0].id')

          # Update records
          curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/dns_records/$ROOT_ID" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data '{"type":"A","name":"${{ env.DOMAIN }}","content":"'"$PUBLIC_IP"'","ttl":1,"proxied":true}'

          curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/dns_records/$WWW_ID" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data '{"type":"A","name":"www","content":"'"$PUBLIC_IP"'","ttl":1,"proxied":true}'

          echo "‚úÖ DNS records updated"

      - name: Health Check
        run: |
          PUBLIC_IP="${{ steps.get-ip.outputs.public_ip }}"
          echo "üè• Running health check..."
          sleep 30

          RESPONSE=$(curl -s --connect-timeout 10 --max-time 30 "http://$PUBLIC_IP/health" || echo "FAILED")

          if echo "$RESPONSE" | grep -q '"status":"ok"'; then
            echo "‚úÖ Health check passed!"
          else
            echo "‚ùå Health check FAILED!"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: Deployment Summary
        run: |
          echo "‚úÖ Deployment completed!"
          echo "üåê IP: ${{ steps.get-ip.outputs.public_ip }}"
          echo "üîó https://${{ env.DOMAIN }}"
