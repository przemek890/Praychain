name: CD - Deploy to AWS ECS

on:
  pull_request:
    branches:
      - main
    types:
      - closed

jobs:
  deploy:
    # Uruchom tylko gdy PR zosta≈Ç zmergowany
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    env:
      AWS_REGION: eu-central-1
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.eu-central-1.amazonaws.com
      ECS_CLUSTER: praychain-cluster
      ECS_SERVICE: praychain-service
      CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      DOMAIN: praychain.pl

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repositories if not exist
        run: |
          for repo in praychain-nginx praychain-backend praychain-voice; do
            if ! aws ecr describe-repositories --repository-names $repo --region ${{ env.AWS_REGION }} 2>/dev/null; then
              echo "Creating repository: $repo"
              aws ecr create-repository --repository-name $repo --region ${{ env.AWS_REGION }}
            fi
          done

      - name: Build Docker images
        run: |
          docker build -t praychain-nginx:latest -f nginx/Dockerfile nginx/
          docker build -t praychain-backend:latest -f backend/Dockerfile backend/
          docker build -t praychain-voice:latest -f voice-service/Dockerfile voice-service/

      - name: Tag and Push images to ECR
        run: |
          docker tag praychain-nginx:latest ${{ env.ECR_REGISTRY }}/praychain-nginx:latest
          docker tag praychain-backend:latest ${{ env.ECR_REGISTRY }}/praychain-backend:latest
          docker tag praychain-voice:latest ${{ env.ECR_REGISTRY }}/praychain-voice:latest

          docker push ${{ env.ECR_REGISTRY }}/praychain-nginx:latest
          docker push ${{ env.ECR_REGISTRY }}/praychain-backend:latest
          docker push ${{ env.ECR_REGISTRY }}/praychain-voice:latest

      - name: Deploy to ECS
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Wait for ECS service to stabilize
        run: |
          echo "Waiting for ECS service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }}

      - name: Get ECS Task Public IP
        id: get-ip
        run: |
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'taskArns[0]' \
            --output text)

          echo "Task ARN: $TASK_ARN"

          ENI_ID=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --tasks $TASK_ARN \
            --region ${{ env.AWS_REGION }} \
            --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
            --output text)

          echo "ENI ID: $ENI_ID"

          PUBLIC_IP=$(aws ec2 describe-network-interfaces \
            --network-interface-ids $ENI_ID \
            --region ${{ env.AWS_REGION }} \
            --query 'NetworkInterfaces[0].Association.PublicIp' \
            --output text)

          echo "Public IP: $PUBLIC_IP"
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT

      - name: Get Cloudflare DNS Record IDs
        id: get-dns-records
        run: |
          ROOT_RECORD_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${{ env.CLOUDFLARE_ZONE_ID }}/dns_records?type=A&name=${{ env.DOMAIN }}" \
            -H "Authorization: Bearer ${{ env.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" | jq -r '.result[0].id')

          echo "Root record ID: $ROOT_RECORD_ID"
          echo "root_record_id=$ROOT_RECORD_ID" >> $GITHUB_OUTPUT

          WWW_RECORD_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${{ env.CLOUDFLARE_ZONE_ID }}/dns_records?type=A&name=www.${{ env.DOMAIN }}" \
            -H "Authorization: Bearer ${{ env.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" | jq -r '.result[0].id')

          echo "WWW record ID: $WWW_RECORD_ID"
          echo "www_record_id=$WWW_RECORD_ID" >> $GITHUB_OUTPUT

      - name: Update Cloudflare DNS Records
        run: |
          PUBLIC_IP="${{ steps.get-ip.outputs.public_ip }}"

          echo "Updating DNS records to point to: $PUBLIC_IP"

          curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/${{ env.CLOUDFLARE_ZONE_ID }}/dns_records/${{ steps.get-dns-records.outputs.root_record_id }}" \
            -H "Authorization: Bearer ${{ env.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data '{
              "type": "A",
              "name": "${{ env.DOMAIN }}",
              "content": "'"$PUBLIC_IP"'",
              "ttl": 1,
              "proxied": true
            }'

          echo "Updated root domain record"

          curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/${{ env.CLOUDFLARE_ZONE_ID }}/dns_records/${{ steps.get-dns-records.outputs.www_record_id }}" \
            -H "Authorization: Bearer ${{ env.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data '{
              "type": "A",
              "name": "www",
              "content": "'"$PUBLIC_IP"'",
              "ttl": 1,
              "proxied": true
            }'

          echo "Updated www subdomain record"

      - name: Health Check - Verify backend is responding
        run: |
          PUBLIC_IP="${{ steps.get-ip.outputs.public_ip }}"

          echo "üè• Running health check on $PUBLIC_IP..."
          echo "‚è≥ Waiting 30 seconds for services to start..."
          sleep 30

          RESPONSE=$(curl -s --connect-timeout 10 --max-time 30 "http://$PUBLIC_IP/health" || echo "FAILED")

          if echo "$RESPONSE" | grep -q '"status":"ok"'; then
            echo "‚úÖ Health check passed!"
            echo "Response: $RESPONSE"
          else
            echo "‚ùå Health check FAILED!"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: Deployment Summary
        run: |
          echo "‚úÖ Deployment completed successfully!"
          echo "üì¶ Images pushed to ECR"
          echo "üöÄ ECS service updated"
          echo "üåê DNS records updated to: ${{ steps.get-ip.outputs.public_ip }}"
          echo "üè• Health check passed"
          echo ""
          echo "Domain: https://${{ env.DOMAIN }}"
          echo "WWW: https://www.${{ env.DOMAIN }}"
